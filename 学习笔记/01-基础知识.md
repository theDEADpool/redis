# 数据类型

|  数据类型   | 底层数据结构  |
|  ----  | ----  |
| string  | 动态字符串SDS |
| list  | 双向链表 和 压缩列表 |
| hash  | 哈希表 和 压缩列表 |
| sorted set  | 跳表 和 压缩列表 |
| set  | 哈希表 和 整数数组 |

# 键值存储
使用哈希表来保存键值对;  
问题:哈希冲突如何解决, 最坏情况所有的键值都在一个哈希桶中形成单向链表;  
通过rehash操作解决, 每次rehash, 会在当前哈希桶数量基础上进行扩容;然后将当前哈希表中数据拷贝到扩容后的哈希表中;  
为了避免全量数据拷贝阻塞主进程, redis采用渐进式rehash, 即每处理一个请求, 将请求对应的哈希桶中所有的数据拷贝到扩容后的哈希表中, 等处理下一个请求时再拷贝其他哈希桶中的数据;  
## rehash时机
通过装载因子load factor来判断, load factor = 哈希中entry数量 / 哈希桶个数;能触发rehash有两种情况:
1. load factor >= 1, 哈希表被允许执行rehash;    
2. load factor >= 5;  
3. 在生产RDB文件 和 AOF重写时, rehash操作是禁止的;  
对于渐进式rehash, 即使没有收到新请求, Redis也会通过定时任务的方式来执行rehash操作, 同时会控制每次rehash的执行时间，不会超过1ms；  

# 底层数据结构
数组 和 双向链表很常见不介绍;  
## 压缩列表
压缩列表实际上类似于一个数组, 数组中的每一个元素都对应保存一个数据。和数组不同的是, 压缩列表在表头有三个字段 zlbytes、zltail 和 zllen, 分别表示列表长度、列表尾的偏移量和列表中的 entry 个数;压缩列表在表尾还有一个 zlend, 表示列表结束;  
| zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend |  
优点是第一个元素和最后一个元素的查询效率很高, 也就对应了Push、Pop操作;  
其他元素的查询则和常规列表一致o(n);  
## 跳表
![跳表](./跳表.jpeg)
通过在常规链表上加多级索引的方式, 来提升查询效率, 复杂度o(logN);  

# 线程模型
最经常会问的一个问题:为什么单线程redis快?  
首先严格来说, redis不是单线程, 或者说单线程是指redis的网络IO和数据读写是由一个线程完成的, 但其他功能比如持久化、集群数据同步等是有其他线程负责执行的;  
单线程进行网络IO和数据读写快的原因是:
1. 内存操作 + 高效率数据结构;  
2. 网络IO多路复用 + 非阻塞模型;  
   
多线程最大的问题就是并发读写数据时会不可避免的要加锁保护, 一是编码复杂, 二是性能下降;  

# 数据持久化
## AOF日志
AOF记录的是redis收到的增、删、改的命令;  
先执行命令再将命令写入AOF, 好处是执行命令的时候会做正确性校验, 可以保证写入AOF文件的命令都是有效的;另外也可以保证写入AOF不会阻塞当前命令的执行;   
问题是:如果当前命令执行完成redis就宕机了, 会造成数据丢失;  

三种写回策略:  
1. Always:同步写回, 每个命令执行完, 同步将日志写回磁盘;一致性最好, 性能最差;  
2. EverySec:每秒写回, 命令执行完只将命令内容写到AOF文件缓冲区, 每1s将缓冲区内容写入磁盘;一致性 和 性能 折中;  
3. No:操作系统控制写回, 命令执行完只将命令内容写到AOF文件缓冲区, 由操作系统决定何时写入磁盘;一致性最差, 性能最好;  

如何避免AOF文件过大?  
AOF重写机制, redis创建一个新的AOF文件, 将数据库当前的键值对写入新AOF文件中。也就是将旧AOF文件中记录的命令做了融合, 对于同一数据先后多次操作, 最终会被合并为一条命令;  

AOF文件写回是由主线程完成的, 但AOF重写则是由单独的线程bgrewriteaof完成的;  
主线程fork子进程时, 子进程会继承主进程的数据, 子进程根据这份数据来构建新的AOF文件;  
但同时主进程还在继续处理新的请求, 因此主进程依然会将新请求的命令写入AOF文件缓冲区;待子进程重写操作完成之后, 会将新增的命令也加入到新的AOF文件中;  

## RDB快照
AOF文件记录的是操作命令, 如果操作非常多, 在redis需要数据恢复的时候就会很慢;RDB快照则是记录的某一个时间点, 数据库中所有的数据内容, 当需要恢复的时候redis直接读取RDB文件, 即可得到全量数据;  
## 是否会阻塞主线程?
redis提供了两个命令:   
1. save:在主线程中执行, 会阻塞;  
2. bgsave:创建子进程, 专门写入RDB文件, 避免阻塞;  
## RDB生成时数据还能更新吗?
redis使用写时拷贝技术, 在生成RDB文件同时也能进行数据更新;  
bgsave子进程是由主线程fork生成的, 可以共享主线程的所有内存数据。bgsave子进程运行后, 开始读取主线程的内存数据, 并把它们写入RDB文件;  
如果主线程对这些数据也都是读操作, 那么, 主线程和bgsave子进程相互不影响。但是如果主线程要修改一块数据, 那么, 这块数据就会被复制一份, 生成该数据的副本。然后bgsave子进程会把这个副本数据写入RDB文件, 而在这个过程中, 主线程仍然可以直接修改原来的数据;  
## 全量快照和增量快照
在执行一次全量快照后, 后续快照记录只需要将增量修改的数据写入RDB文件即可;增量快照就需要由额外的内存资源来记录某一时间范围内哪些数据发生了变化;  

# 混合持久化
Redis 4.0中提出了一个混合使用AOF日志和RDB快照的方法。简单来说, RDB快照以一定的频率执行, 在两次快照之间, 使用AOF日志记录这期间的所有命令操作;  
这样一来, 快照不用很频繁地执行, 这就避免了频繁fork对主线程的影响。而且AOF日志也只用记录两次快照间的操作, 也就是说, 不需要记录所有操作了, 因此, 就不会出现文件过大的情况了, 也可以避免重写开销;  

# 主从数据同步
主从采用读写分离, 从库只可读, 主库可读可写;可以避免写操作落到不同实例上导致数据不一致的情况;  
## 第一次同步-全量同步
主从库建立连接:  
从库发送psync命令给主库, 此时同步offset为-1, 表示全量同步;  
主库响应fullresync命令携带同步offset, 同时主库会执行bgsave命令, 生成RDB文件;  
主库将RDB文件发送给从库, 从库收到RDB文件首先清空当前数据库内容, 然后加载RDB文件;  
主库将RDB文件之后的写操作记录在replication buffer中;主库完成RDB文件发送后就会将replication buffer中的内容同步给从库;  
replication buffer是主从同步时, 主库作为从库客户端的一个buffer, 也就是说有多少个从库，主库就会创建多少个replication buffer;  

## 级联模式分担主库同步压力
如果所有的从库都从主库同步数据, 会影响主库对于正常请求的处理, 因此通过“主-从-从”的模式, 将部分同步工作交给其他从库去完成;  
即少量的一级从库连接主库, 而其他的从库则作为二级或者三级从库连接到上一级的从库上;  

## 增量同步
如果全量同步过程中出现异常, 有部分数据没有完成同步, 那后续的同步过程则采用增量同步;  
当主从库断连之后, 主库会把写操作命令写入replication buffer, 同时也会写入repl_backlog_buffer环形缓冲区;  
当连接恢复之后, 从库依然是发送psync命令, 携带当前的offset, 将master_repl_offset和slave_repl_offset之间的数据同步给从库;  
既然是环形缓冲区, 就会出现写满的情况, 此时主库会复写掉旧数据, 会导致主从之间的数据不一致;  
repl_backlog_buffer与replication buffer不同，是一个专用buffer, 不论有多少个从库，主库都只会创建一个repl_backlog_buffer用来记录尚未同步的写操作；  

# 哨兵机制
解决主从模式下, 主库发生故障后无法继续提供服务的问题;  
哨兵有三个能力:监控、选主和通知;
监控, 即周期性的向主从库发ping命令, 如果主从库没有在规定时间内相应, 则哨兵会将其标记为下线状态;如果发现主库下线, 则重新选主;  
选主完成后, 哨兵会通知其他从库, 从库与新主库建连之后会进行主从数据同步, 同时哨兵会将新主库也通知客户端;  

## 下线判断
如果从库ping响应超时, 则被标记为主管下线;如果是主库ping超时, 则不能简单的标记为主观下线, 要防止误判;  
防止误判的方式是通过哨兵集群, 当集群里N/2 + 1的哨兵都判断主库为主观下线, 则哨兵集群会将主库标记为客观下线;判定为客观下线后才会重新选主;  

## 如何选主
1. 筛选条件
要判断从库与主库之间的连接状态, 如果从库与主库之间的断连次数超过了一定的阈值, 则不能被选为主库;  
2. 选举规则
打分制:从库优先级、从库同步offset、从库id;  
优先级最高的从库分最高, 优先级一样的则offset最新的从库分最高, offset都一样则根据id大小, id最小的分最高;  

## 哨兵集群
哨兵之间的发现需要用到redis的pub/sub机制;每个哨兵先和主库建连, 然后从主库上订阅其他哨兵的连接信息;之后哨兵之间便能知道彼此的ip和port;主库会有一个sentinel:hello的频道, 提供哨兵之间互相发现;  
哨兵也需要和从库之间建连, 通过向主库发送INFO命令, 得到从库的列表;  
同样哨兵也是通过pub/sub机制来来与客户都安进行事件交互;  
具体由哪一个哨兵实例来执行主从切换的过程, 也会有一个选举过程:当某个哨兵判定主库主观下线时, 会将该信息通过通过is-master-down-by-addr发给其他哨兵, 其他哨兵会对此进行投票, 当某个哨兵获得了满足客观下线条件的赞成票之后, 就会执行客观下线;  
此时该哨兵会再向其他哨兵发消息表示自己希望执行客观下线, 其他哨兵对此进行投票, 该过程称为Leader选举, 如果有多个哨兵都发起了Leader选举, 那投票的哨兵实例就只能将赞成票投给其中一个Leader;   
如果一轮选举过程都没有选出Leader, 那集群会过一段时间重新开始选举, 直到选举成功;

# Redis集群
当数据量越来越大, 有两种扩展方式:  
1. 纵向扩展:即增加单台Redis实例的配置, 比如内存、cpu、硬盘等;当碰到数据持久化等情况, 还是会出现查询耗时增加的情况;  
2. 横向扩展:将原本单个实例存储的数据分散到多个Redis实例中进行存储;就需要解决分布式数据管理问题;  

Redis Cluster采用的就是横向扩展的方式, 采用Hash slot来处理数据与实例之间的映射关系;一个Redis Cluster提供16384个hash slot;  
实际在部署Redis Cluster时候, 会自动建立slot与Redis实例之间的对应关系, 也可以通过cluster addslot命令根据每个实例的不同, 人工指定每个实例上分配的slot数量;手动分配的时候需要将16384个slot都完成分配, 否则Redis集群无法正常工作;  
## 重定向
当集群中实例出现增减时, slot的分配会发生变化, 客户端缓存的slot信息不准确, 此时Redis cluster提供了一个重定向机制, 即当实例上没有客户端想要查询的数据时, 需要给另外一个实例再次发送请求;  
但客户端如何知道应该给哪个新实例发送请求?前一个实例会通过MOVE命令告诉客户端新实例的地址;  
如果客户端访问数据对应slot正在迁移中, 则客户端会收到一个ASK信息, 客户端需要先通过ASK命令向新实例请求, 在执行对应的操作;与MOVE命令不同, ASK命令不会更新客户端缓存的slot信息, 下次客户端还是会先向旧实例发送请求;  