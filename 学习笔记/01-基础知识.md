# 数据类型

|  数据类型   | 底层数据结构  |
|  ----  | ----  |
| string  | 动态字符串SDS |
| list  | 双向链表 和 压缩列表 |
| hash  | 哈希表 和 压缩列表 |
| sorted set  | 跳表 和 压缩列表 |
| set  | 哈希表 和 整数数组 |

# 键值存储
使用哈希表来保存键值对；  
问题：哈希冲突如何解决，最坏情况所有的键值都在一个哈希桶中形成单向链表；  
通过rehash操作解决，每次rehash，会在当前哈希桶数量基础上进行扩容；然后将当前哈希表中数据拷贝到扩容后的哈希表中；  
为了避免全量数据拷贝阻塞主进程，redis采用渐进式rehash，即每处理一个请求，将请求对应的哈希桶中所有的数据拷贝到扩容后的哈希表中，等处理下一个请求时再拷贝其他哈希桶中的数据；  

# 底层数据结构
数组 和 双向链表很常见不介绍；  
## 压缩列表
压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束；  
| zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend |  
优点是第一个元素和最后一个元素的查询效率很高，也就对应了Push、Pop操作；  
其他元素的查询则和常规列表一致o(n);  
## 跳表
![跳表](./跳表.jpeg)
通过在常规链表上加多级索引的方式，来提升查询效率，复杂度o(logN)；  

# 线程模型
最经常会问的一个问题：为什么单线程redis快？  
首先严格来说，redis不是单线程，或者说单线程是指redis的网络IO和数据读写是由一个线程完成的，但其他功能比如持久化、集群数据同步等是有其他线程负责执行的；  
单线程进行网络IO和数据读写快的原因是：
1. 内存操作 + 高效率数据结构；  
2. 网络IO多路复用 + 非阻塞模型；  
   
多线程最大的问题就是并发读写数据时会不可避免的要加锁保护，一是编码复杂，二是性能下降；  

# 数据持久化
## AOF日志
AOF记录的是redis收到的增、删、改的命令；  
先执行命令再将命令写入AOF，好处是执行命令的时候会做正确性校验，可以保证写入AOF文件的命令都是有效的；另外也可以保证写入AOF不会阻塞当前命令的执行；   
问题是：如果当前命令执行完成redis就宕机了，会造成数据丢失；  

三种写回策略：  
1. Always：同步写回，每个命令执行完，同步将日志写回磁盘；一致性最好，性能最差；  
2. EverySec：每秒写回，命令执行完只将命令内容写到AOF文件缓冲区，每1s将缓冲区内容写入磁盘；一致性 和 性能 折中；  
3. No：操作系统控制写回，命令执行完只将命令内容写到AOF文件缓冲区，由操作系统决定何时写入磁盘；一致性最差，性能最好；  

如何避免AOF文件过大？  
AOF重写机制，redis创建一个新的AOF文件，将数据库当前的键值对写入新AOF文件中。也就是将旧AOF文件中记录的命令做了融合，对于同一数据先后多次操作，最终会被合并为一条命令；  

AOF文件写回是由主线程完成的，但AOF重写则是由单独的线程bgrewriteaof完成的；  
主线程fork子进程时，子进程会继承主进程的数据，子进程根据这份数据来构建新的AOF文件；  
但同时主进程还在继续处理新的请求，因此主进程依然会将新请求的命令写入AOF文件缓冲区；待子进程重写操作完成之后，会将新增的命令也加入到新的AOF文件中；  

## RDB快照
AOF文件记录的是操作命令，如果操作非常多，在redis需要数据恢复的时候就会很慢；RDB快照则是记录的某一个时间点，数据库中所有的数据内容，当需要恢复的时候redis直接读取RDB文件，即可得到全量数据；  
## 是否会阻塞主线程？
redis提供了两个命令：   
1. save：在主线程中执行，会阻塞；  
2. bgsave：创建子进程，专门写入RDB文件，避免阻塞；  
## RDB生成时数据还能更新吗？
redis使用写时拷贝技术，在生成RDB文件同时也能进行数据更新；  
bgsave子进程是由主线程fork生成的，可以共享主线程的所有内存数据。bgsave子进程运行后，开始读取主线程的内存数据，并把它们写入RDB文件；  
如果主线程对这些数据也都是读操作，那么，主线程和bgsave子进程相互不影响。但是如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后bgsave子进程会把这个副本数据写入RDB文件，而在这个过程中，主线程仍然可以直接修改原来的数据；  
## 全量快照和增量快照
在执行一次全量快照后，后续快照记录只需要将增量修改的数据写入RDB文件即可；增量快照就需要由额外的内存资源来记录某一时间范围内哪些数据发生了变化；  

# 混合持久化
Redis 4.0中提出了一个混合使用AOF日志和RDB快照的方法。简单来说，RDB快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作；  
这样一来，快照不用很频繁地执行，这就避免了频繁fork对主线程的影响。而且AOF日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销；  